= Sources
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Because sources must be placed at the beginning of a flow, they cannot appear directly in the test. To test a source, you must have a flow with the source you want to test, and then a test that triggers the source.

There are several types of sources, each with its own distinct testing strategy.

== Sources That Emit a Response

The most common kind of test is when the source generates a synchronous response. To test a source that emits a response, you must trigger the source to get that response, and then assert it.

For example, in the case of an `http:listener`, you can trigger the source with an `http:request`:

[source, xml, linenums]
----
<flow name="responseSourceFlow">
    <test-connector:listener config-ref="aConfig" />
    <logger level="DEBUG" message="Listener executed"/>
</flow>

<munit:test name="responseSourceFlowTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="responseSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Hit the source -->
        <...>
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[payload]" expected="#['Example']"/>
    </munit:validation>
</munit:test>
----

== Polling Sources

Because a polling source polls items periodically with a given scheduling strategy, the test must trigger the polling source and wait for the next poll. Then, the test can validate the response generated by the polling source.

=== Trigger a Single Time

You can trigger the polling source a single time. For example, for a `file:listener` operation, you can trigger the polling source by creating new files:

[source, xml, linenums]
----
<flow name="pollingSourceFlow">
    <test-connector:polling-source>
        <scheduling-strategy>
            <fixed-frequency frequency="500"/>
        </scheduling-strategy>
    </test-connector:polling-source>
    <munit-tools:queue>
        <munit-tools:value>#[payload]</munit-tools:value>
    </munit-tools:queue>
</flow>

<munit:test name="pollingSourceTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="pollingSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Trigger the source -->
        <...>
        <!-- Wait for polling source to trigger -->
        <munit-tools:dequeue target="storedPayload"/>
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[vars.storedPayload]" expected="#['Example']"/>
    </munit:validation>
</munit:test>
----

=== Trigger Multiple Times

You can trigger the polling source multiple times:

[source, xml, linenums]
----
<flow name="pollingSourceFlow">
    <test-connector:polling-source>
        <scheduling-strategy>
            <fixed-frequency frequency="500"/>
        </scheduling-strategy>
    </test-connector:polling-source>
    <munit-tools:queue>
        <munit-tools:value>#[payload]</munit-tools:value>
    </munit-tools:queue>
</flow>

<munit:test name="pollingSourceTest">
    <munit:enable-flow-sources>
        <munit:enable-flow-source value="pollingSourceFlow"/>
    </munit:enable-flow-sources>
    <munit:execution>
        <!-- Trigger the source -->
        <...>
        <!-- Wait for polling source to trigger -->
        <until-successful maxRetries="10" millisBetweenRetries="100">
            <munit-tools:assert-that expression="#[MunitTools::queueSize()]" is="#[MunitTools::equalTo(5)]"/>
        </until-successful>
    </munit:execution>
    <munit:validation>
        <!-- Assert payload -->
        <foreach collection="#[1 to 5]">
            <munit-tools:dequeue target="storedPayload"/>
            <munit-tools:assert-equals actual="#[vars.storedPayload]" expected="#['Example']"/>
        </foreach>
    </munit:validation>
</munit:test>
----

== See Also

* xref:sources.adoc[Creating Message Sources with the Mule SDK]