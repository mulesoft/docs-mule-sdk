= Parameterized Tests
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

A parameterized suite allows you to run the same tests with different inputs. See xref:munit::munit-parameterized-suite.adoc[MUnit Parameterized Test Suite] for more information.

== Configuration Parameterization Example

The following example shows a test suite with two parameterizations, each of them pointing to a different configuration:

.Operation with a config
[source, java, linenums]
----
public Integer withConfig(@Config ExampleConfig config) {
    return config.getValue();
}
----

You can test different configurations as follows:

.Test that runs against different configurations
[source, xml, linenums]
----
<munit:config name="parameterized-configs-test">
    <munit:parameterizations>
        <munit:parameterization name="config1">
            <munit:parameters>
                <munit:parameter propertyName="config" value="config1"/>
                <munit:parameter propertyName="expected" value="1"/>
            </munit:parameters>
        </munit:parameterization>
        <munit:parameterization name="config2">
            <munit:parameters>
                <munit:parameter propertyName="config" value="config2"/>
                <munit:parameter propertyName="expected" value="2"/>
            </munit:parameters>
        </munit:parameterization>
    </munit:parameterizations>
</munit:config>

<test-connector:config name="config1" value="1"/>
<test-connector:config name="config2" value="2"/>

<munit:test name="parameterizedConfigsTest">
    <munit:execution>
        <test-connector:with-config config-ref="${config}" />
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[payload]" expected="#[${expected}]"/>
    </munit:validation>
</munit:test>
----

== Input Data Parameterization Example

Suppose that you want to execute one operation but with different inputs, each with different expected outputs: for example, testing an operation that replaces one string input with another. Your operation uses the following syntax:

.Operation for Different Inputs
[source, java, linenums]
----
public String replace(String input, String toReplace, String replacement) {
    return input.replace(toReplace, replacement);
}
----

Your test for several different inputs to one operation looks like this:

.Test Case with Different Inputs
[source, xml, linenums]
----
<munit:config name="parameterized-inputs-test">
    <munit:parameterizations>
        <munit:parameterization name="singleCharacter">
            <munit:parameters>
                <munit:parameter propertyName="input" value="foo"/>
                <munit:parameter propertyName="toReplace" value="o"/>
                <munit:parameter propertyName="replacement" value="e"/>
                <munit:parameter propertyName="expected" value="fee"/>
            </munit:parameters>
        </munit:parameterization>
        <munit:parameterization name="multipleCharacter">
            <munit:parameters>
                <munit:parameter propertyName="input" value="example"/>
                <munit:parameter propertyName="toReplace" value="ple"/>
                <munit:parameter propertyName="replacement" value="ination"/>
                <munit:parameter propertyName="expected" value="examination"/>
            </munit:parameters>
        </munit:parameterization>
    </munit:parameterizations>
</munit:config>

<munit:test name="parameterizedInputsTest">
    <munit:execution>
        <test-connector:replace input="${input}" toReplace="${toReplace}" replacement="${replacement}" />
    </munit:execution>
    <munit:validation>
        <munit-tools:assert-equals actual="#[payload]" expected="${expected}"/>
    </munit:validation>
</munit:test>
----




