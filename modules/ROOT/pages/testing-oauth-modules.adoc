= OAuth-Enabled Modules
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

Mule runtime engine supports authorization through various OAuth grant types, including the Authorization Code grant type, which allows an external system (for example, your Mule application) to operate on behalf of a user without requiring user authentication.

However, because the Authorization Code grant type forces human intervention in the authentication process that identifies users using OAuth (OAuth dance), building an automated test for an application using this grant type is challenging.

To overcome this challenge, use the Storage Event processor to bypass the OAuth dance by manually providing a valid access token. Ensure the following requirements are met:

* You must manually obtain the token.
* You must be aware that the token eventually expires. 
+
How often the token expires depends on the service provider you are connecting to.
* You must obtain a new token and update the test with it.

== Example: OAuth-Enabled Module

Consider the following configuration of Salesforce Connector using OAuth authentication:

[source,xml,linenums]
----
<os:config name="TokenObjectStore_Config" />

<os:object-store name="tokenStore" persistent="true" config-ref="TokenObjectStore_Config" /> //<1>

<sfdc:config name="sfdcConfig" ...>
	<sfdc:oauth-connection ....>
		<sfdc:oauth-authorization-code ... />
<sfdc:oauth-callback-config ... />
<sfdc:oauth-store-config objectStore="tokenStore" /> //<2>
	</sfdc:oauth-connection>
</sfdc:config>
----
[calloutlist]
.. The application defines an object store named `tokenStore`.
.. The application uses the `tokenStore` object store to store the OAuth token.

To use the OAuth token stored in `tokenStore` in an MUnit test, create a flow and insert your token in an MUnit Storage Event processor:

[source,xml,linenums]
----
<flow name="storeOAuthToken">
   <munit-tools:store-oauth-token resourceOwnerId="testUser"
                                  ownerConfigName="sfdcConfig"
                                  accessToken="${accessToken}"
                                  refreshToken="${refreshToken}"
                                  expiresIn="${expiresIn}"
                                  state="${state}"
                                  overwrite="true"
                                  objectStore="tokenStore">
       <munit-tools:additional-parameters>#[{param1: 'foo', param2: 3}]</munit-tools:additional-parameters>
   </munit-tools:store-oauth-token>
</flow>
----

Note that the `ownerConfigName` element matches the name of the Salesforce configuration. The access token and other properties shown here are placeholders for the values that you obtain by manually performing the OAuth dance. You can then supply the token to the MUnit test through system properties, a properties file, or any other mechanism you choose.

After you supply the token values, your MUnit test has the following structure:

[source,xml,linenums]
----
<munit:test name="oauthTest">
    <munit:behavior>
	<flow-ref name="storeOAuthToken" /> //<1>
    </munit:behavior>
    <munit:execution>
            <sfdc:upsert config-ref="sfdcConfig" resourceOwnerId="testUser" ... /> //<2>
    </munit:execution>
    <munit:validation>
            .... Your assertions here ....
    </munit:validation>
</munit:test>
----
[calloutlist]
.. Inserting the token by invoking the `storeOAuthToken` flow is the very first step in the test.
.. The `<sfdc:upsert>` operation references the same config name and `resourceOwnerId` that matches the token you inserted.
